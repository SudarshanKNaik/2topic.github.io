<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Learning Outcomes</title>
    <style>
        /* Global styles */
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f4f9ff;
            color: #333;
            margin: 0;
            padding: 0;
        }

        h1 {
            text-align: center;
            color: #007BFF;
            padding: 20px;
            background-color: #ffffff;
            margin: 0;
            border-bottom: 4px solid #007BFF;
        }

        h2 {
            color: #ffffff;
            background-color: #007BFF;
            padding: 10px;
            border-radius: 5px;
            margin-top: 20px;
            font-size: 1.5rem;
        }

        h3 {
            color: #0056b3;
            margin-top: 20px;
            font-size: 1.2rem;
        }

        p, ul {
            margin-left: 20px;
            font-size: 1rem;
        }

        ul {
            list-style-type: square;
        }

        section {
            margin: 40px auto;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            max-width: 1100px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        strong {
            color: #333;
        }

        footer {
            text-align: center;
            padding: 20px;
            background-color: #007BFF;
            color: #ffffff;
            margin-top: 40px;
            font-size: 0.9rem;
        }

        /* Responsive styling */
        @media (max-width: 768px) {
            h2 {
                font-size: 1.2rem;
            }

            h3 {
                font-size: 1rem;
            }

            p, ul {
                margin-left: 15px;
                font-size: 0.9rem;
            }

            section {
                margin: 20px;
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <h1>Learning Outcomes</h1>

    <section>
        <h2>1. Dijkstra’s Algorithm</h2>
        <ul>
            <li>Understand how to find the shortest path from a source node to all other nodes in a graph with non-negative edge weights.</li>
            <li>Analyze the time complexity of Dijkstra's Algorithm using adjacency lists and priority queues.</li>
            <li>Recognize the importance of a greedy approach in solving optimization problems.</li>
        </ul>
    </section>

    <section>
        <h2>2. Floyd’s Algorithm (Floyd-Warshall Algorithm)</h2>
        <ul>
            <li>Learn to find the shortest paths between all pairs of vertices in a weighted graph.</li>
            <li>Understand the dynamic programming approach used in the algorithm.</li>
            <li>Recognize the trade-offs in terms of time and space complexity (O(V³)) compared to single-source algorithms like Dijkstra.</li>
        </ul>
    </section>

    <section>
        <h2>3. Warshall’s Algorithm</h2>
        <ul>
            <li>Master how to compute the transitive closure of a directed graph.</li>
            <li>Gain an understanding of how Warshall’s Algorithm can be used to determine reachability between nodes.</li>
        </ul>
    </section>

    <section>
        <h2>4. Kruskal’s Algorithm</h2>
        <ul>
            <li>Understand how to find the Minimum Spanning Tree (MST) of a graph using the greedy approach.</li>
            <li>Learn the importance of sorting edges by weight and using union-find (disjoint-set) to avoid cycles.</li>
            <li>Compare Kruskal’s Algorithm with Prim’s Algorithm in terms of applicability and complexity.</li>
        </ul>
    </section>

    <section>
        <h2>5. Prim’s Algorithm</h2>
        <ul>
            <li>Learn how to construct the MST starting from any arbitrary node.</li>
            <li>Understand how the priority queue (or heap) optimizes the selection of the next smallest edge.</li>
            <li>Compare Prim’s Algorithm to Kruskal’s Algorithm for dense and sparse graphs.</li>
        </ul>
    </section>

    <section>
        <h2>6. Bellman-Ford Algorithm</h2>
        <ul>
            <li>Understand how to find the shortest path from a single source to all vertices in a graph, including graphs with negative weight edges.</li>
            <li>Learn to detect negative weight cycles in a graph.</li>
            <li>Compare Bellman-Ford with Dijkstra’s Algorithm and understand their use cases.</li>
        </ul>
    </section>

    <section>
        <h2>7. Boyer-Moore Algorithm</h2>
        <ul>
            <li>Gain insights into pattern matching in strings with a focus on how the algorithm skips unnecessary comparisons.</li>
            <li>Understand the significance of preprocessing the pattern for efficient matching in large texts.</li>
            <li>Explore how Boyer-Moore improves on brute-force string matching algorithms.</li>
        </ul>
    </section>

    <section>
        <h2>8. Knuth-Morris-Pratt (KMP) Algorithm</h2>
        <ul>
            <li>Learn the importance of preprocessing the pattern to create the "longest prefix-suffix" (LPS) array for skipping redundant comparisons.</li>
            <li>Understand how KMP achieves linear time complexity for pattern matching.</li>
            <li>Recognize its application in searching for patterns in DNA sequences, documents, and more.</li>
        </ul>
    </section>

    <section>
        <h2>9. Depth-First Search (DFS)</h2>
        <ul>
            <li>Understand how to traverse or explore a graph using recursion or a stack.</li>
            <li>Learn to find connected components, solve pathfinding problems, and detect cycles in directed and undirected graphs.</li>
            <li>Apply DFS in solving puzzles like mazes, generating subsets, or solving backtracking problems.</li>
        </ul>
    </section>

    <section>
        <h2>10. Breadth-First Search (BFS)</h2>
        <ul>
            <li>Master the use of a queue for level-wise exploration of graphs or trees.</li>
            <li>Learn to find the shortest path in an unweighted graph.</li>
            <li>Understand BFS's role in finding all nodes at a specific distance from a source, and its use in solving puzzles like "Knight’s Tour."</li>
        </ul>
    </section>

    <footer>
        
    </footer>
</body>
</html>
