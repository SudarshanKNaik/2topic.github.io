<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithms and Data Structures</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f9f9f9;
            color: #333;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        h1, h2 {
            color: #2c3e50;
        }
        h1 {
            text-align: center;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #ffffff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
        }
        .section h2 {
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        ul {
            list-style-type: square;
            margin: 10px 0;
            padding-left: 20px;
        }
    </style>
</head>
<body>
    <h1>Algorithms and Data Structures</h1>

    <div class="section">
        <h2>1. Problems in Nature</h2>
        <ul>
            <li><strong>Iteration:</strong> Spider web patterns, social media feeds, bee hive construction.</li>
            <li><strong>Recursion:</strong> Patterns in flower petals, sea shells, and food chains.</li>
            <li><strong>Backtracking:</strong> Beaver dam construction, solving puzzles like crosswords or Sudoku.</li>
        </ul>
    </div>

    <div class="section">
        <h2>2. Time and Space Efficiency</h2>
        <ul>
            <li><strong>Time Efficiency:</strong> Measures execution time as input size grows.</li>
            <li><strong>Space Efficiency:</strong> Evaluates memory usage during processing.</li>
            <li><strong>Importance:</strong> Faster algorithms enhance performance; space-efficient designs are essential for memory-constrained environments.</li>
            <li><strong>Classes of Problems:</strong> O(1), O(log n), O(n), O(n²), O(2ⁿ).</li>
            <li><strong>Orders of Growth:</strong> Best case, average case, worst case.</li>
        </ul>
    </div>

    <div class="section">
        <h2>3. Sorting Algorithms</h2>
        <ul>
            <li><strong>Bubble Sort:</strong> Simple but inefficient (O(n²)).</li>
            <li><strong>Merge Sort:</strong> Efficient for large datasets (O(n log n)).</li>
            <li><strong>Quick Sort:</strong> Fast average-case sorting (O(n log n)).</li>
            <li><strong>Heap Sort:</strong> Priority-based sorting (O(n log n)).</li>
        </ul>
    </div>

    <div class="section">
        <h2>4. Graph Algorithms</h2>
        <ul>
            <li><strong>Kruskal’s Algorithm:</strong> Creates minimum spanning trees.</li>
            <li><strong>Dijkstra’s Algorithm:</strong> Finds shortest paths in weighted graphs.</li>
            <li><strong>Floyd-Warshall Algorithm:</strong> Computes all-pairs shortest paths.</li>
            <li><strong>Prim’s Algorithm:</strong> Incremental spanning tree construction.</li>
            <li><strong>Applications:</strong> Used in network design, logistics, and transportation optimization.</li>
        </ul>
    </div>

    <div class="section">
        <h2>5. Hierarchical Data Representation</h2>
        <ul>
            <li><strong>Binary Search Tree (BST):</strong> Efficient searching and updates.</li>
            <li><strong>AVL Tree:</strong> Balanced structure for predictable performance.</li>
            <li><strong>Trie:</strong> Supports fast prefix-based searches.</li>
            <li><strong>Heap:</strong> Efficient for priority management.</li>
        </ul>
    </div>

    <div class="section">
        <h2>6. Array Query Algorithms</h2>
        <ul>
            <li><strong>Prefix Sums:</strong> Quick range queries.</li>
            <li><strong>Segment Trees:</strong> Efficient range operations.</li>
            <li><strong>Fenwick Trees:</strong> Fast cumulative frequency updates.</li>
            <li><strong>Applications:</strong> Gaming leaderboards, data analytics, real-time systems.</li>
        </ul>
    </div>

    <div class="section">
        <h2>7. Difference Between Tree and Graph</h2>
        <ul>
            <li><strong>Tree:</strong> Hierarchical with no cycles (used in file systems).</li>
            <li><strong>Graph:</strong> General structure with nodes and edges (used in networks).</li>
            <li><strong>Traversals:</strong></li>
            <ul>
                <li>Tree: Inorder, Preorder, Postorder.</li>
                <li>Graph: DFS, BFS.</li>
            </ul>
        </ul>
    </div>

    <div class="section">
        <h2>8. Spanning Trees and Shortest Paths</h2>
        <ul>
            <li><strong>Spanning Trees:</strong> Minimal connectivity for networks (Kruskal's, Prim's).</li>
            <li><strong>Shortest Paths:</strong> Optimization in navigation (Dijkstra’s, A*).</li>
        </ul>
    </div>

    <div class="section">
        <h2>9. Algorithm Design Techniques</h2>
        <ul>
            <li><strong>Brute Force:</strong> Tries all solutions.</li>
            <li><strong>Divide and Conquer:</strong> Recursively solves subproblems (e.g., Merge Sort).</li>
            <li><strong>Dynamic Programming:</strong> Avoids redundant work (e.g., Fibonacci).</li>
            <li><strong>Greedy Algorithms:</strong> Local optimization for global results (e.g., Kruskal’s).</li>
        </ul>
    </div>
</body>
</html>
